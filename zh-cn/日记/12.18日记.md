作为新手，很容易混淆 `for` 和 `while` 的使用场景，或者不知道该把谁放在循环条件里。

判断标准非常直接：看指针移动的**确定性（Determinism）**。

简单来说，**谁负责“遍历”，谁就是循环变量。**

我们将双指针场景分为两大类来理解：

### 1. “主从模式” (Sliding Window / 快慢指针)
**场景特点**：必须把数组完整地扫一遍，不能遗漏任何一个元素。
**典型代码结构**：`for` 循环驱动右指针（或快指针）。

在这类问题中（包括刚才做的 209 题），通常有一个**“主指针” (通常是 `right`)**。
*   **任务**：它的任务是**无条件地**向右走，负责把新数据“拉入”我们的计算范围。
*   **移动逻辑**：每一轮循环必须 `+1`，雷打不动。
*   **为什么选它做循环变量**：因为算法的进度是由它控制的。只要它没走到头，程序就不能停。

而另一个指针（`left`）是**“从指针”**：
*   **任务**：它的移动是**被动**的、**条件触发**的（比如和大于 Target 了，`left` 才动）。
*   **移动逻辑**：可能不动，可能动一步，也可能连续动好几步（通过内部的 `while`）。

**代码模板：**
```java
// right 是主驱动，控制循环次数
for (int right = 0; right < nums.length; right++) {
    // 1. 进数据
    
    // 2. 判断是否需要收缩 left (left 是被动的)
    while (条件不满足) {
        left++; 
    }
}
```

### 2. “对撞模式” (左右指针 / 二分查找)
**场景特点**：两个指针分别在两头，向中间靠近。
**典型代码结构**：`while (left < right)`。

在这类问题中（比如“有序数组的两数之和”），**没有主次之分**。
*   **任务**：`left` 和 `right` 共同寻找一个目标。
*   **移动逻辑**：这一轮是 `left` 动，还是 `right` 动，完全取决于当前的计算结果（比如 `sum > target` 还是 `sum < target`）。我们无法预知下一轮谁动，也没人是“固定走一步”的。
*   **为什么不用 for**：因为没有一个指针是固定步长的，强行用 `for` 会写出很多 `if-else` 和 `i--`，逻辑非常乱。

**代码模板：**
```java
int left = 0;
int right = nums.length - 1;

// 没有固定的循环变量，由两者位置关系决定何时停止
while (left < right) {
    if (条件偏大) {
        right--; // 只有这时候 right 才动
    } else if (条件偏小) {
        left++;  // 只有这时候 left 才动
    } else {
        // 找到了
    }
}
```

### 3. “合并模式” (归并排序 / 合并两个有序数组)
**场景特点**：有两个数组，两个指针 `p1`, `p2` 分别在两个数组上跑。
**典型代码结构**：`while (p1 < n && p2 < m)`。

这也属于**不确定性移动**。
*   如果 `nums1[p1] < nums2[p2]`，则 `p1` 动。
*   否则 `p2` 动。
*   这也是无法用 `for` 循环通过单一变量控制的。

---

### 总结法则

当你面对一道新题，犹豫该怎么写循环时，问自己一个问题：

**“在这个算法里，有没有一个指针是必须每一步都往后移，绝对不回头的？”**

*   **有**（比如滑动窗口的右边界）：用 **`for` 循环**，让这个指针做循环变量。
*   **没有**（两边都要根据情况判断谁走）：用 **`while` 循环**，条件通常是指针的相对位置（如 `left < right`）。

**回到刚才的第 209 题**：
我们需要尝试以数组中**每一个元素**作为子数组的结尾。
“每一个元素” = 必须遍历 = 确定性移动。
所以，`right` 指针必须作为 `for` 循环的变量。

---

**“擂台法”的初始化策略**。

在 LeetCode 和实际开发中，只要涉及到**“寻找最小值”**的场景，几乎都会用到 `Integer.MAX_VALUE`。

### 1. 为什么要这么做？（逻辑推演）

我们需要在一个循环中不断更新“当前的最小值”。通常代码是这样的：
`minLength = Math.min(minLength, currentLength);`

这就引入了一个问题：**第一次比较时，`minLength` 应该是多少？**

#### 假设初始化为 0 (错误示范)
如果你写 `int minLength = 0;`：
*   第一次算出的有效长度是 4。
*   执行 `Math.min(0, 4)`，结果是 0。
*   第二次算出的有效长度是 2。
*   执行 `Math.min(0, 2)`，结果还是 0。
*   **后果**：因为 0 比任何合法的正数长度都小，你的结果会被永久“锁死”在 0，永远无法更新为真实的长度。

#### 正确做法：初始化为“正无穷大”
在 Java 中，`Integer.MAX_VALUE` 代表 `int` 能表示的最大数字（2147483647）。

如果你写 `int minLength = Integer.MAX_VALUE;`：
*   第一次算出的有效长度是 4。
*   执行 `Math.min(2147483647, 4)`，结果是 4。（**成功把第一个有效值存进去了**）
*   第二次算出的有效长度是 2。
*   执行 `Math.min(4, 2)`，结果是 2。（**成功更新为更小的值**）

**结论**：
初始化为最大整数，是为了**确保任何一个有效的（比它小的）计算结果，都能在第一次比较时成功覆盖掉初始值**。

---

### 2. LeetCode 通用

这是解决最值问题的标准模版，请死记硬背：

*   **找最小值 (Min)**：变量必须初始化为 **最大值** (Infinity)。
    ```java
    int minVal = Integer.MAX_VALUE;
    // 循环中
    minVal = Math.min(minVal, currentVal);
    ```

*   **找最大值 (Max)**：变量必须初始化为 **最小值** (-Infinity) 或者 **0** (如果题目保证没有负数)。
    ```java
    int maxVal = Integer.MIN_VALUE; 
    // 或者 int maxVal = 0;
    // 循环中
    maxVal = Math.max(maxVal, currentVal);
    ```

---

### 3. 什么时候会用到？（常见题型）

这种写法在 LeetCode 的三种题型中出现率极高：

#### A. 数组/滑动窗口求最小长度 (当前题目)
*   **场景**：最短的子数组、最小的覆盖区间。
*   **代码**：`minLen = Math.min(minLen, right - left + 1)`

#### B. 动态规划 (Dynamic Programming) 求最小成本
*   **场景**：比如“零钱兑换”（凑成 11 元最少需要几枚硬币）、“最小路径和”（从矩阵左上角走到右下角的最小数字和）。
*   **逻辑**：在计算 dp 数组时，因为要选最小的方案，默认值必须设为 `MAX_VALUE`，否则状态转移方程无法工作。

#### C. 图论的最短路径 (Shortest Path)
*   **场景**：Dijkstra 算法。
*   **逻辑**：一开始我们不知道从起点到某个点 B 的距离是多少，所以默认距离设为“无穷大” (`Integer.MAX_VALUE`)。当我们发现一条路能走到 B 且距离是 10 时，因为 `10 < 无穷大`，所以更新距离为 10。


