今天使用 **Docsify + GitHub Pages** 搭建了一个专门用于记录 LeetCode 刷题的博客。

整体流程是：

- 使用 **VS Code + Git** 进行日常记录与版本管理  
- 在 VS Code 中通过 **snippets** 定义了一个名为 `note` 的模板  
- 每次新建 Markdown 文件时，可以一键生成统一的刷题笔记结构  


---

今天复盘了之前做过的三道题，结果发现**全忘了** 😅  
让 Gemini 帮我系统性地总结了一下**双指针**的两种常见模式：**对撞指针**和**快慢指针**。

总结的切入点很好，是从 **数据的特征** 和 **算法的目标** 这两个核心维度来区分。

> 决定使用哪一种指针，本质上取决于：  
> **你想解决什么问题，以及输入数据具有什么性质。**

---

### 1. 对撞指针 (Left-Right Pointers)

**方向**：`left = 0`, `right = n-1`，向中间靠近。  

**核心应用场景**：利用**有序性**来缩小搜索范围。  

当题目条件中包含“**有序数组**”这个关键词，或者涉及到**两端数据的对比**时，90% 的概率是在考对撞指针。

* **逻辑原理**：  
  因为数组是有序的，所以数组的**最小值在最左边**，**最大值在最右边**。  
  通过比较这两个端点的值，我们可以确定地排除掉左边或者右边的一整个区间。

* **判断标准**：  
  1. **输入数据**：必须是**有序的**（或者半有序，如旋转数组）。  
  2. **目标**：寻找两个数满足某个条件（如和为 target），或者利用两端的极值属性（如有序数组平方）。  
  3. **操作**：通常不修改原数组结构，而是搜索结果或填充新数组。

* **典型题目**：  
  - **二分查找**（特殊的对撞）：`nums[mid]` 和 target 对比  
  - **两数之和 II（有序数组）**：如果 `nums[left] + nums[right] > target`，因为有序，最大的数（right）必须减小，所以 `right--`  
  - **有序数组的平方（你的上一题）**：负数平方后可能变大，最大值一定出现在两端，必须同时观察左右才能确定  
  - **反转字符串**：交换头尾字符，两端向中间推进  

---

### 2. 快慢指针 (Fast-Slow Pointers)

**方向**：`slow = 0`, `fast = 0`，同向移动。  

**核心应用场景**：**原地修改**数组（In-place Modification）。  

当题目要求“**原地删除**”、“**原地去重**”、“**移动元素**”，并且**不使用额外空间**时，基本可以直接锁定快慢指针。

* **逻辑原理**：  
  可以把数组理解为两个状态区间：  
  - **`fast` 指针**：充当**读取器（Reader）**，负责遍历整个数组，判断当前元素是否“有用”  
  - **`slow` 指针**：充当**写入器（Writer）**，维护新数组的边界  

  在任意时刻，`[0, slow-1]` 区间内的元素，都是已经处理完成的“新数据”。

* **判断标准**：  
  1. **输入数据**：是否有序通常不重要  
  2. **目标**：对数组进行**过滤**、**覆盖**或**压缩**  
  3. **操作**：直接修改原数组，返回值通常是新数组的长度

* **典型题目**：  
  - **移除元素（LeetCode 27）**：将不等于 `val` 的元素读出来，写到 `slow` 指向的位置  
  - **删除有序数组中的重复项**：把不重复的元素依次写回数组前部  
  - **移动零**：将非零元素按顺序写回前缀区域  

---

### 总结对比表

| 特征           | 对撞指针 (Left, Right)              | 快慢指针 (Slow, Fast)                 |
| :------------- | :---------------------------------- | :------------------------------------ |
| **指针初始化** | 头和尾 (`0`, `n-1`)                 | 都是头 (`0`, `0`)                     |
| **移动方向**   | 相对而行 ($\rightarrow \leftarrow$) | 同向而行 ($\rightarrow \rightarrow$)  |
| **依赖条件**   | 数据通常需要**有序**                | 数据顺序无关紧要                      |
| **核心目的**   | **搜索 / 查找**（利用极值缩小范围） | **修改 / 重构**（读写分离、覆盖数据） |
| **你的案例**   | **有序数组平方**                    | **移除元素**                          |

---

**一句话技术总结：**

- 如果**不改变数组长度**，只是为了**找东西**，并且数据是**有序的** → **对撞指针**
- 如果需要**逻辑删除 / 移动元素**，本质是在**重写数组前缀** → **快慢指针**
