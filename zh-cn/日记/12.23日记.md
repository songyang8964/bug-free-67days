## 关于Leetcode里的装箱和拆箱


**口诀：**
**“单个元素”自动变，“整个数组”要手动。**

我们分两部分把这个规则讲透。

---

### 一、 什么时候是“自动”的？ (90% 的情况)

只要你操作的是 **单个数字**，Java 编译器都会帮你把 `int` 和 `Integer` 互相转换。你不需要写额外代码。

#### 1. 自动装箱 (Auto-Boxing): `int` -> `Integer`
**场景**：你需要一个对象（比如放入集合），但你手里只有一个基本数字。

*   **往集合里 `add` 时**：
    ```java
    List<Integer> list = new ArrayList<>();
    list.add(5); 
    // 自动变成：list.add(Integer.valueOf(5));
    ```
*   **给 Integer 变量赋值时**：
    ```java
    Integer a = 100;
    // 自动变成：Integer a = Integer.valueOf(100);
    ```

#### 2. 自动拆箱 (Auto-Unboxing): `Integer` -> `int`
**场景**：你需要做数学运算，或者需要用基本类型接数据。

*   **从集合里遍历/取值时**：
    ```java
    Integer a = 100;
    int b = a; 
    // 自动变成：int b = a.intValue();
    ```
*   **做加减乘除运算时**（对象不能直接加减，必须拆成数字）：
    ```java
    Integer x = 10;
    Integer y = 20;
    int sum = x + y; 
    // 自动变成：x.intValue() + y.intValue();
    ```
*   **做大小比较时** (`>`, `<`)：
    ```java
    if (x > 5) { ... } 
    // 自动变成：if (x.intValue() > 5)
    ```

---

### 二、 什么时候必须“手动”？ (重要的 10%)

这是你做 LeetCode 最容易卡住的地方。当涉及到 **“容器”对“容器”**，或者 **“数组”对“数组”** 的时候，Java **不会**自动帮你在两种数组间转换。

#### 1. `int[]` 和 `Integer[]` 互转
这是最坑的地方。`int[]` 是一个整体，`Integer[]` 也是一个整体，它们在内存里长得完全不一样，Java 无法自动转换。

*   **错误写法**：
    ```java
    int[] arr = {1, 2, 3};
    // 编译报错！无法将 int[] 转换为 Integer[]
    Integer[] objArr = (Integer[]) arr; 
    ```

*   **正确写法（必须手动循环）**：
    你必须创建一个新数组，然后一个一个把元素搬过去（搬运的时候，单个元素会自动装/拆箱）。
    ```java
    // Set<Integer> 转 int[] (LeetCode 349 的情况)
    Set<Integer> set = new HashSet<>(); 
    set.add(1);
    
    // 必须手动：
    int[] res = new int[set.size()];
    int i = 0;
    for (Integer num : set) {
        res[i] = num; // 这里的 num 也就是单个元素，是自动拆箱的
        i++;
    }
    ```

#### 2. `List<Integer>` 转 `int[]`
LeetCode 经常要求返回 `int[]`，但我们在函数内部常用 `ArrayList<Integer>` 方便操作。最后这就需要转换。

*   **错误写法**：
    ```java
    List<Integer> list = new ArrayList<>();
    // 编译报错！Java 不支持这种直接转换
    int[] arr = (int[]) list.toArray(); 
    ```

*   **正确写法（必须手动）**：
    ```java
    int[] arr = new int[list.size()];
    for(int i=0; i<list.size(); i++) {
        arr[i] = list.get(i);
    }
    ```

#### 3. 这里的“手动”还包含一个特殊情况：NULL 陷阱
虽然单个元素是自动的，但如果 `Integer` 对象是 `null`，自动拆箱会崩溃（抛出 `NullPointerException`）。

*   **一定要小心**：
    ```java
    Integer a = null;
    int b = a; // 报错！因为试图对 null 调用 intValue()
    ```
    **面试技巧**：如果你的 `HashMap` 或 `List` 可能包含 `null`，在转成 `int` 前必须检查是否为 `null`。

---

### 总结图表

| 操作           | 涉及类型                              | 是否自动？    | 备注                           |
| :------------- | :------------------------------------ | :------------ | :----------------------------- |
| 赋值           | `int` $\leftrightarrow$ `Integer`     | **是**        | `Integer a = 5;`               |
| 集合添加       | `list.add(int)`                       | **是**        | `list` 存的是对象              |
| 运算           | `Integer + Integer`                   | **是**        | 先拆箱再计算                   |
| **数组转换**   | `int[]` $\leftrightarrow$ `Integer[]` | **否 (手动)** | **内存结构不同，必须循环复制** |
| **列表转数组** | `List<Integer>` $\to$ `int[]`         | **否 (手动)** | **LeetCode 高频考点**          |

